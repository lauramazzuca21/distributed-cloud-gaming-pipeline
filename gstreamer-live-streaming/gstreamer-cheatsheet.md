# GStreamer C & CLI Cheatsheet

## Initialization


## GObject
## GstElement and GstElementFactory
### C
```
GObject
    ╰──GInitiallyUnowned
        ╰──GstObject
            ╰──GstElement
```
GstElement is the abstract base class needed to construct an element that can be used in a GStreamer pipeline.  
GstElementFactory is the object used to create intances of elements. Since it can be instantiated as an active object, it has both methods and functions.   

GElementFactory is instantiated with the function:  
```
GstElementFactory *
gst_element_factory_find (const gchar * name)
```
This way, we can have a GstElementFactory representing a specific kind of element and use it when we want to instantiate many elements of the same kind.  
The GstElementFactory names possible are defined inside the class GstElementFactory and can be listed through the CLI (see below).
Then, to create an element we use the method:  
```
GstElement *
gst_element_factory_create (GstElementFactory * factory,
                            const gchar * name)
```
passing the previously created GstElementFactory as first parameter and the (optional) name the element should be given.  
Example:  
```
   #include <gst/gst.h>

   GstElement *src;
   GstElementFactory *srcfactory;

   gst_init (&amp;argc, &amp;argv);

   srcfactory = gst_element_factory_find ("filesrc");
   g_return_if_fail (srcfactory != NULL);
   src = gst_element_factory_create (srcfactory, "src");
```

Instead of doing the double passage above we can simply use instead:  
```
GstElement *
gst_element_factory_make (const gchar * factoryname,
                          const gchar * name)
```
used to create a GstElement by providing:  
* the factoryname (same as we would have provided before during GstElementFactory instantiation)
* the optional name of the element itself

Example:  
```
  GstElement *source, *sink;
  source = gst_element_factory_make ("videotestsrc", "source");
  sink = gst_element_factory_make ("autovideosink", "sink");
```

###CLI

List all available elements types:
```
gst-inspect-1.0
```
List specific element-s properties:
```
gst-inspect-1.0 <element-name>
```

##Pipeline
###C
```
GObject
    ╰──GInitiallyUnowned
        ╰──GstObject
            ╰──GstElement
                ╰──GstBin
                    ╰──GstPipeline
```
All elements in GStreamer must typically be contained inside a pipeline before they can be used, because it takes care of some clocking and messaging functions.   
A pipeline is a particular type of bin, which is the element used to contain other elements. Therefore all methods which apply to bins also apply to pipelines.  
We create the pipeline with:  
```
  GstElement *pipeline;
  pipeline = gst_pipeline_new ("test-pipeline");
```
and then build it with previously created source and sink elements:  
```
gst_bin_add_many (GstBin * bin,
                  GstElement * element_1,
                  ... ...)
```
Example:  
```
gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL);
```
if we wanted to add only one at the time we could have used:  
```
gboolean
gst_bin_add (GstBin * bin,
             GstElement * element)
```
Finally, we need to link the elements with each other using:  
```
gboolean
gst_element_link (GstElement * src,
                  GstElement * dest)
```
Example:  
```
  if (gst_element_link (source, sink) != TRUE) { //error in pipeline linking
    g_printerr ("Elements could not be linked.\n");
    gst_object_unref (pipeline);
    return -1;
  }
```
The order counts, because links must be established following the data flow (this is, from source elements to sink elements).

### GstState

## GstMessage

## GstBus
It is the object responsible for delivering to the application the GstMessages generated by the elements, in order and to the application thread. This last point is important, because the actual streaming of media is done in another thread than the application.

## GstPad
If a container embeds multiple streams (one video and two audio tracks, for example), the demuxer will separate them and expose them through different output ports. In this way, different branches can be created in the pipeline, dealing with different types of data.  

The ports through which GStreamer elements communicate with each other are called pads. There exists sink pads, through which data enters an element, and source pads, through which data exits an element. It follows naturally that source elements only contain source pads, sink elements only contain sink pads, and filter elements contain both.  
# GNOME
## GSignal
### C
GSignals are a crucial point in GStreamer. They allow you to be notified (by means of a callback) when something interesting has happened. Signals are identified by a name, and each GObject has its own signals.

```
g_signal_connect(instance, detailed_signal, c_handler, data)
```
* instance: the instance to connect to. (e.g. a GstElement, in our case)
* detailed_signal: a string of the form "signal-name::detail". 
* c_handler: the GCallback to connect.
* data: data to pass to c_handler calls.
